# NEL设计文档

## 前言

本文档为2024年毕昇杯编译大赛参赛队伍NEL的编译器设计文档。本编译器面向官方提供的sysy语言，以llvm为ir，以riscv为最终目标代码的体系结构。

## 运行控制

NEL将所有的优化开关和执行控制都放到了Manager.java中执行

通过解析输入的命令行指令，NEL支持O0(无优化输出)和O1(全优化输出)两种模式，并且可以快速地在Manager顶层进行修改以控制具体优化的开关。

## 工具类

### pair

经典的键值对，不再赘述

### NelLinkedList

NEL专门设计重写的链表单元，用于管理所有的需要顺序存储的代码状态(例如指令等)，支持安全性检查，是NEL安全高效代码的基石。

- 具体用法包括链表的常用操作前插入、后插入、尾插入、头插入、自删除、遍历、索引取等
- 安全性检查包括检查并发修改异常、移除孤立指令，插入已有父亲链表的指令等

### CFG

采用深度优先遍历构建

### DG

使用Tarjan算法构建

## 前端部分

前端部分采取递归下降法读入输入流，然后建立语法树，并进行一定程度的整合。

### 词法分析

使用token封装每一个词法单元，包括但不限于数字(NUM),标识(Identify)等，具体种类较为繁杂，在此不再赘述

为了方便减少具体递归下降流程的压力，我们选择将一些功能(例如字符解析和判断)封装为具体的文件：StringHandler。

值得一提的是，`stoptime`和`starttime`的参数需要行号，因此我们在token中设置属性行号，并且设置静态变量`line`
，每次读取到一个`\n`就将其加一

### 语法分析

建立语法树需要进行词法分析，我们用一个parser进行递归下降来解决问题。经过语法分析后，得到了一个由语法单元组成的AST(
抽象语法树)，便于后续向中端代码转化。

在建立语法树的过程中，我们在AST.java文件夹定义了语法树的各个节点和操作方式。

### 中端代码生成

由AST向中端代码转化的过程是十分复杂的，我们为了保证整个流程的清晰可控，将所有这部分的主干逻辑都写到了文件visitor.java中，

#### 符号表

建立中端的value的体系结构，确定对象的对应关系需要建立符号表。我们将语法树的每一个ident都和symbol符号相绑定，然后每一个符号都和一个llvm中间value相对应，这样就可以在读取到一个ident的时候知道它是对哪个value进行操作。中端的命名编号采取
指令+序号的格式。

#### 常量拦截

一些在前端方便进行的优化可以在前端就进行优化，以减少后面的开销。例如两个操作数都是常数的情况可以在前端阶段进行拦截。

## 中端部分

### 中端体系

中端参考使用llvm进行构建，方便在中端进行测试和定位bug。

### value

在中端，依据llvm的要求，将所有的类的父类设置为value，便于指令的操作。同时针对所有value都设置了类型属性，包括：基本属性：`BaseType`
和其衍生子类:`I1,I32,I64,F32`，指针类`PointerType`和以其所指value类型为依据划分的其他各种type，数组类`ArrayType`
.这样的type体系方便对value进行针对性的判断，方便采取不同的执行措施。

### Use-User

在中端，最为关键的是关于use关系的维护与设置。

简而言之，在我们的设计中，将User作为使用一个value的主体，例如一条指令，可以使用多个value，那么它就是这些Value的user。所有User都不重、乱序地维护了所有Value的使用关系。所有Value都设置了一个`replaceAllUseOf`
的方法，将所有使用该value的user的所使用的该value替换为另一个Value，方便后续中端进行优化与代码等价变换。

我们将上述的使用关系继承以自定义的工具类NelLinkedListNode，方便进行管理，同时提供了充分的安全性检查，减少了bug的发生。

### 指令体系(Instruction)

我们使用Instruction类来代表中端的所有指令，从该类派生出如下的类，作为中端操作各种value的指令。Instruction继承自User，因此它可以使用各种Value作为Operand。

```
VOID, // null
RETURN,CALL,PHI,ALLOC,STORE,LOAD,BRANCH,JUMP,
SItofp,FPtosi,Zext,Sext,TRUNC,
Icmp,Fcmp,GEP,BitCast,ADD,SUB,FADD,FSUB,MUL,DIV,FMUL,FDIV,REM,FREM,
// extend
FMADD,FMSUB,FNEG,FNMADD,FNMSUB,MIN,MAX,
// bitwise operation
SHL,LSHR,ASHR,AND,OR,XOR,
PHICOPY,
MOVE
```

在我们的设计中，每一个指令都与一个基本块相绑定，这样可以正确地反映它和基本块之间的对应关系。

需要注意的是，在我们的中端设计中，依然采取类似前端AST一样的递归架构。指令使用Value，同时指令本身也是Value，该value代表指令执行的结果。

### 基本块(BasicBlock)

基本块是指令的存储单元，也是指令移动和控制流的基本单元，是我们的设计中最重要的部分之一。

我们的中端一直维护着子模块的从属关系，因此每一个基本块都和一个函数对应，同时基本块也持有它本身的所有中端指令。

在我们的设计中，每一个基本块的末尾一定是一条br指令，且br指令一定会出现在基本块的末尾，维护这一良好的性质为我们后续对控制流的优化起到了十分重要的作用。

### 中端控制流(CFG)

在每一个基本块中，都维护了它在执行路径上的所有前驱和后继，这方便地提取了中端块的控制流图

### 循环(Loop)

循环一直是中端控制流的重点与优化的重中之重，因此我们在设计的时候就将循环作为中端的一个基本类来设计实现。通过计算支配关系，我们可以从基本块中提取并维护循环内部的`headers`,`preHeader`,`enterings`,`exitings`,`latch`
等基本块和参与本层循环的基本块。同时考虑到循环的嵌套，每一个循环中还维护一个所有子循环的集合，并且维护一个本层循环的深度，方便后续对循环进行针对性优化

### 函数(Function)

函数是所有循环和基本块的承载体。

在函数中设置内部类Argument，作为函数的参数。

在函数类中，我们设计了许多方法来以函数为粒度进行操作，例如提取基本块序列，提取循环序列，提取支配关系图和支配顺序遍历基本块。考虑到函数本身的封闭性，我们约定所有value不出函数，因此每个value仅仅从属于一个function。

## 后端部分

### 后端体系

根据对riscv体系的抽象结构，建立如下类：

- `RiscvModule`:包括全局变量、函数等在内的所有riscv单元的最终模块类
- `RiscvFunction`:riscv函数，以一个标签的形式出现在输出文件中，实际是标签后所有内容的集合。包含了函数内的所有基本块
- `RiscvBlock`:承载了所有后端指令，用NelLinkedList控制其安全性
- `RiscvInstrution`：后端指令类，继承自NelLinkedList，具体包括
    - `La`:获取地址的伪指令
    - `li`:加载立即数的伪指令
    - `R3`:有三个操作数的指令
    - `R2`:有两个操作数的指令
    - `LS`:load或者store等与地址打交道的存在
    - `B`:条件跳转指令
    - `J`无条件跳转指令

- `RiscvGlobalVar`:全局变量，包括全局浮点数池和全局数组

同时，设置了操作数(Opreand)类，作为指令可以操作或者使用的单元：

- Reg:寄存器，在寄存器分配阶段前为虚拟寄存器，在寄存器分配阶段后会填充对应的真实物理寄存器
- Imm：立即数，不和栈偏移相关的具体数值，在寄存器分配前就可以得到其数值，用于li、addi或者对全局变量的偏移
- Address：栈上偏移offset，考虑到需要在所有代码生成结束且寄存器分配处理溢出之后才能知道所有在栈上的偏移，因此对于所有和栈指针相关的偏移数值均以address填入，在寄存器分配后移动栈指针进行回填

### 代码生成

该部分由中间代码生成为riscv代码

codegen.java为执行该逻辑的主体，StackManager和VirRegMap为执行该逻辑的辅助类

按照顺序读入中端的Module，，自顶向下地建立llvm向riscv的转化。

值得注意的是：stackManager将中端的value和地址相对应，同时保证ld等操作时刻为8对齐，VirRegMap则将中端的value与一个虚拟寄存器对应，在codegen阶段，采取忠实翻译，将所有的优化内容交给单独的后端pass进行。

### 寄存器分配

在代码生成阶段，所有寄存器都作为虚拟寄存器存在(除了sp等一些需要特殊确定的特殊功能寄存器，以预着色的方式存在于指令中)
，在寄存器分配阶段，首先通过活跃变量分析分析出每一个虚拟寄存器的生命周期和def-use链，然后建立冲突图进行寄存器分配，具体的分配策略参考了《现代编译原理》这本书，算法不再赘述。

### 函数调用与寄存器保护

在寄存器保护的时候，我们采取"全局寄存器交给被调用者保护，临时寄存器交给调用者保护"
的策略，同时如果可知调用的函数使用的临时寄存器范围，可以选择性不保护调用的函数不使用的临时寄存器。

### 寄存器分配后处理

寄存器分配后，所有有关栈的偏移都已经确定，因此我们将专门运行一个回填函数，首先将栈指针移动，保证在所有调用外部函数的时候

## 优化部分

### 中端优化

为了保证原有翻译的正确性，我们不在前端生成中间代码时使用任何的优化手段，尽量保证中端绝对正确的翻译。同时，为了减少不同中端优化之间的耦合性，我们将每一种中端优化以pass的形式实现，可以方便的开关，同时保证代码编写地条理清晰。

#### GEP规约

将指针的计算归约到最后一维度，使计算过程暴露更多的优化机会，也为其他地址优化提供统一的格式。

#### ConstIdx2Value

将常下标的数组访问内联成值。

#### LocalArrayLift

将局部数组提升到全局，减少栈分配空间以及访存次数

#### SoraPass

将聚合的数组拆分成多个标量寄存器，减少访存次数

#### DeadArgEliminate

消除函数中“无用”的参数

#### DeadCodeEliminate

消除对于结果不产生影响的分支跳转

#### DeadCodeEliminate

消除对于结果不产生影响的死代码

#### DeadLoopEliminate

消除对于结果不产生影响的循环

#### DeadRetEliminate

消除函数中无用的返回值

#### RemoveBlocks

消除无用的基本块与不可达的基本块，简化控制流图

#### SimplifyCFG

简化控制流图：

- 合并基本块
- 消除只有跳转语句的基本块
- 修改跳转目标，节约跳转语句的次数

#### 冗余存储的消除

消除冗余的存储，减少访存次数，具体包括：

- 编译期间能判断无法被使用的store

#### 冗余加载的消除

消除冗余的加载，减少访存次数，具体包括：

- 编译期间能确定的Load的值
- 已经存在标量寄存器中Load的值

#### 无用指令的消除

消除无用的指令，减少指令数目

#### FuncCache

函数缓存，将递归函数的返回值缓存，减少函数调用次数

#### FuncIncline

函数内联，将函数内联到调用处，减少函数调用过程的开销

#### TailCall2Loop

尾递归优化，将尾递归优化为循环，减少函数调用的开销

#### 分支预测

对于循环中的分支，根据循环的特性进行分支预测，为后端基本块的排布服务

#### LoopSimplifyForm

将建立好的循环规约为规范形式，具体包括：

- 唯一的preheader
- 唯一的latch
- 所有的exit被header支配

将循环规约后方便其他循环优化变换

#### LCSSA

在循环的出口块插入phi指令，将循环内部变量的外部使用限定为LCSSA，方便循环优化变换

#### LoopUnswitching

循环分支提升，尽量将循环中的分支提取出来，为其他优化创造新的机会

#### LoopUnroll

分为ConstLoopUnroll和LoopUnroll

- ConstLoopUnroll：对于编译期可确定次数循环，我们首先预估展开后大小，若不超过阈值，采用全展开策略
- LoopUnroll：对于循环次数不固定的循环，目前采用4路展开策略

#### LVN

局部值编号。按照支配树进行替换，不需要多跑GCM保证正确

#### GVN

全局值编号，用于消除全局冗余计算，该算法较为经典不再赘述；进行GVN pass后需要再进行GCM pass以保证正确

#### GCM

全局代码移动。将代码在不破坏支配顺序的前提下移动到循环深度浅、支配深度深的地方

#### SCEV

参考了往年队伍CMMC的设计，在此基础上改进以识别循环中的归纳变量

#### IndVars

#### ism2imm

模式匹配

### 后端优化

NEL重视后端优化，因此针对体系结构多了许多的优化。

#### 后端优化总领

我们通过这样的思路对后端代码进行优化：寄存器分配优先，尽量减少访存，充分利用存取速度较慢的体系结构弱势，充分利用内存与cache等的思路。

#### 带权寄存器分配

我们采取了带cost的图着色寄存器分配策略，通过中端传来的循环信息在后端建立循环结构，并且根据该信息，以循环的深度和执行次数综合为寄存器进行赋值，可以保证在不得不溢出的情况下优先溢出循环深度较浅、执行次数较少的寄存器，尽可能地减少溢出带来的损失。

#### 循环不变量外提

虽然中端实现了循环不变量外提，但是考虑到后端与中端的差异性，该优化在后端依旧大有可为。

具体来讲，后端会从中端提取所有循环块的信息，并获取他的所有header、entering和exiting，然后遍历所有循环内部的块，将所有类似于
li、lla等数值不会有任何变化的指令外提到循环外，以削减每次循环的强度。

#### 浮点数常量池化

浮点数在codegen阶段采取每读取一个浮点数则新建一个全局浮点数变量的方式存起来，难点是其每次都要单独lla然后再通过load取值。事实上这对性能损耗较大，该优化将所有的浮点数都存到了数组pool中，这样访问多个浮点数的时候可以充分利用内存和缓存的局部性，将有关的浮点数组都加载到内存中，这样就极大减少了访问内存的开销

#### 块排序

考虑到CPU取值有固定的取值缓存，我们希望有紧密跳转关系地两个块在内存上尽可能地临近，所以使用`Pettis-Hansen `
算法进行块排序，这样可以尽可能提高指令执行的局部性，充分利用指令缓存

#### 块内联

为了让CPU全速发射指令，同时减少指令块换入换出的消耗，我们采取了将无条件跳转指令进行内联的操作，具体操作为将J指令删除，然后将j指令的目标块的所有指令粘贴至J指令的所属块。这样能极大增加指令的局部性，减少跳转，同时也有利于CPU全速转发

#### 控制流图简化

在中端和后端的前期，为了保证指令格式的简洁，约定每一个块中br指令一定在块的最末尾。但是在真正执行的时候会造成很多负面影响。因此需要对cfg进行一定程度的简化。

##### 重定向

对于所有仅有一个j指令的块，将指向它的块的指令所指向的块都换成该j指令指向的块

##### j省略

经过块重排，保证跳转概率较大的几个块大概率会依次排布，如果j的目标块就是下一个紧邻的块，就将j指令省略。

#### 访存优化

考虑到计算的局部性，可能在一个块内的集中部分会出现多次访存同一个地址的行为。在后端建立一个访存表，跟踪记录所有内存的加载情况和寄存器关联。如果某个寄存器已经存放了某一处内存的值，那么对这个内存的取就可以转化为寄存器间的移动，从而减少访存。

#### 计算优化

在后端需要尽可能多的方式对计算进行优化，减少寄存器以减少寄存器分配的压力。

其中的优化策略包括：

- 立即数加载复用(如果有较短区间内两次加载一样的数值，那么就将两条指令所用的寄存器合并)
- 地址加载复用(如果有较短区间内两次加载一样的地址，那么就将两条指令所用的寄存器合并)
- srai+slli等位运算可以用更短的方式(如andi)优化。
- icmp+br向beq等指令转化：由于中端和后端指令含义的不同，在翻译icmp和br的时候会出现指令冗余，因此这里就将冗余指令收集并翻译为后端效果更好的beq指令，以减少指令数目

#### 指令共基优化

在中端对循环进行四路展开之后，一个块内会有大量的GEP重复计算，他们的基指针大概率都是相同的。因此可以将这样的`pointer=base addi x +ls 0(pointer)`
优化为`ls x(base)`，从而为内存与缓存提供新的优化可能

#### 单字变双字存取优化

考虑到存取是整个指令系统开销最大的指令之一，因此要尽量减少存取。该优化将两个访存连续内存的指令优化为一条访存内存的双字指令，可以减少访存的次数。为了保证正确性，该优化需要注意在两条内存的访问期间不会操作(存取)该地址范围。

#### 内存对齐优化

经过实验，我们发现，sd/ld指令在地址值不为8的倍数时性能显著劣于地址值为8的倍数时的情况，因此在后端的访存有关指令时，我们都会确保双字指令的地址一定是8的倍数。

具体实现策略为：

- 控制sp指针每次移动的偏移量为16的倍数
- 在栈上开辟空间时如果对应的对象为双字，则保证其对于sp指针的偏移量为8的倍数，例如当前在sp上分配了一个4字节，然后又分配一个8字节的对象，那么该对象的偏移起始地址是8而不是4。
- 中端对类型为指针的value会进行对齐分析，分为4对齐,8对齐，不确定对齐三种对齐方式，方便在进行单变双字优化时进行选择性优化。

#### 乘除常数优化

考虑到riscv体系中，乘除法指令的代价非常巨大(经过实验发现,mul指令的代价为3-4条add，div的代价为10条add，rem的代价为25条add)，因此需要考虑用一系列加法和移位指令来替代常数作为参数的乘除指令

##### 乘法优化

将乘法规约为x*n，其中n为常数的格式。针对该n选择不同的指令组合。类似dp表的格式，在程序初始化的时候计算在乘法代价内(let mul_cost = 3)条指令可能产生的组合，例如3可以视为两次位移求和，也可以按一次sh1add计算。最终可以根据其n生成一个乘法方案(mul_plan)，供codegen阶段翻译生成

##### 除法/取余优化

本优化算法具体可以参考论文[Division by Invariant Integers using Multiplication](https://dl.acm.org/doi/10.1145/773473.178249)，由于算法实现类似，因此数学原理和转化过程不再赘述，这里仅提出我们算法的优化：考虑在取模的数是2的幂次的情况下，若保证被取模的数是正数，可以简便地使用andi来获取其低位数值，快速计算其模值。如果不能保证，论文中的算法是将其转化为除法优化+相减求余数。而事实上，可以通过在运行时分支判断的方法简便求余数。

```
	bge		a0, zero, rem_helper_temp_BB1
	addiw	t1, a0, 1
rem_helper_temp_BB1:
	andi	t1, t1, -2
	subw	t1, a0, t1
```









