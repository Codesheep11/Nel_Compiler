# 优化文档

> Waysome

## Visitor 翻译

### While

condBlock

whileBlock

followBlcok



## 

## mIR 设计

### Value

- type

所有的Value 都在使用的时候作为某种值；

- descriptor

每一个  Value  除了JAVA 对象的区分之外，提供一个字符串用于指称和输出；

对于 指令、基本块、函数而言；

descriptor 本身并不区分局部或全局，@,% 在输出时被确定；

### Instruction

局部变量所对应的地址；？

在栈上的；



指令；

本身

### Function

抽象的函数表示；

### Constant

类型

- Boolean
- Integer
- FloatingPoint
  - 只包含 F32_Type




不包含指针常量类型；

不变量的存储方式；

初始化为常量





visit 产生数组的时候，在中端的存储形式是什么；

### GlobalValue

定义了编译时确定的全局值；

必须被初始化；

当外部链接时，允许不带 initializer

约定ident 和 value；





## 函数内联 FuncInline

module 顶层是函数之间的调用关系；

内联函数在这里指在某一个具体调用的位置，将Call 替换为函数文本。

不意味着消除本身函数的定义，故对函数的展开可以保留 Call 指令；

这意味着对任意一个函数的展开可以是独立于其他函数的；



展开需要考虑的决策因素：

积极：

- 减少函数调用开销；
- 提高局部性；
- 启发其他优化；

消极：

- 可执行文件增大（不重要）；
- 降低缓存效率；

### 内联策略

初步策略是全内联；

但保留后续做动态规划的尝试；



实现上，

出度为零的点（考虑自调用）是可直接展开的；

内联函数的决策问题；

展开的情况：





### 内联实现

创建 insertBlock ， replaceUseOf, 对于一个函数；

它维护的Function ，其中指令的构成是怎样的；

局部的变量，通过；

alloc 

load

加入insertBlock ；

基本块的划分：



对于一个 Func 内部基本块并非是连续的；

是否是静态的；

遍数的；

优化的遍数，次序；



填写后部指令；



若是独立的，clone 之后，替换对 param 的使用；

展开的方法：

参数：

返回值：调整为 phi 指令；

不保证 phi  仅出现在头部；



#### run

判定内联；

- 建反图；
- 拓扑排序；
- 

逐步内联和删除旧函数；

直接使用强内联策略全展开；

MakeReserveMap

对于每一个Function，在通过user 的类判定指令类型；

维护原函数到





对于

为什么传递callers

transCallToFunc

retBloack  



带 if else 的块 如何返回；

调整为 load 指令； 统一的 load ？

中途反悔；

对一个函数所含的BasicBlock 表，其中的指令 直接被 replaceUseOfWith 替代；



维护拓扑我觉得事不必要的；

