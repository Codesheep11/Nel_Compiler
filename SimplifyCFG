package backend.Opt;

import backend.riscv.*;
import

import java.util.HashMap;

public class SimplifyCFG {
    public static final int INF = 0x70000000;

    public static boolean redirectGoto(RiscvFunction func) {
        HashMap<RiscvBlock, RiscvBlock> redirect = new HashMap<>();

        for (RiscvBlock block : func.blocks()) {
            if (block.instructions().size() != 1)
                continue;
            int inst = block.instructions().get(0);
            RiscvBlock targetBlock = null;
            if (ctx.instInfo.matchUnconditionalBranch(inst, targetBlock)) {
                redirect.put(block, targetBlock);
            }
        }

        if (redirect.isEmpty())
            return false;

        boolean modified = false;
        for (RiscvBlock block : func.blocks()) {
            for (int inst : block.instructions()) {
                RiscvBlock targetBlock = null;
                double prob;
                if (ctx.instInfo.matchBranch(inst, targetBlock, prob)) {
                    if (redirect.containsKey(targetBlock)) {
                        ctx.instInfo.redirectBranch(inst, redirect.get(targetBlock));
                        modified = true;
                    }
                } else if (requireFlag(ctx.instInfo.getInstInfo(inst).getInstFlag(), InstFlagIndirectJump)) {
                    MIRJumpTable jumpTable = (MIRJumpTable) inst.getOperand(1).reloc();
                    for (RiscvBlock item : jumpTable.data()) {
                        if (redirect.containsKey(item)) {
                            item = redirect.get(item);
                            modified = true;
                        }
                    }
                }
            }
        }
        return modified;
    }

    public static boolean removeUnreachableCode(RiscvFunction func) {
        Set<RiscvBlock> visit = new HashSet<>();
        Queue<RiscvBlock> q = new LinkedList<>();
        HashMap<RiscvBlock, RiscvBlock> nextHashMap = new HashMap<>();
        RiscvBlock prev = null;

        for (RiscvBlock block : func.blocks()) {
            if (prev != null) {
                nextHashMap.put(prev, block);
            }
            prev = block;
        }

        q.add(func.blocks().get(0));
        visit.add(q.peek());

        boolean modified = false;

        while (!q.isEmpty()) {
            RiscvBlock u = q.poll();

            Runnable touchNext = () -> {
                RiscvBlock next = nextHashMap.get(u);
                if (next != null && visit.add(next)) {
                    q.add(next);
                }
            };

            List<Integer> instructions = u.instructions();
            boolean stop = false;
            for (ListIterator<Integer> iter = instructions.listIterator(); iter.hasNext(); ) {
                int inst = iter.next();
                RiscvBlock targetBlock = null;
                double prob;
                if (ctx.instInfo.matchBranch(inst, targetBlock, prob)) {
                    if (visit.add(targetBlock)) {
                        q.add(targetBlock);
                    }
                } else if (requireFlag(ctx.instInfo.getInstInfo(inst).getInstFlag(), InstFlagIndirectJump)) {
                    MIRJumpTable jumpTable = (MIRJumpTable) inst.getOperand(1).reloc();
                    for (RiscvBlock item : jumpTable.data()) {
                        targetBlock = item;
                        if (visit.add(targetBlock)) {
                            q.add(targetBlock);
                        }
                    }
                }
                if (requireFlag(ctx.instInfo.getInstInfo(inst).getInstFlag(), InstFlagTerminator | InstFlagNoFallthrough)) {
                    stop = true;
                }

                if (stop) {
                    while (iter.hasNext()) {
                        iter.next();
                        iter.remove();
                    }
                    modified = true;
                    break;
                }
            }

            if (!stop) touchNext.run();
        }

        int oldCount = func.blocks().size();
        func.blocks().removeIf(block -> !visit.contains(block));
        int newCount = func.blocks().size();

        return modified || oldCount != newCount;
    }

    public static boolean removeUnusedLabels(RiscvFunction func) {
        RiscvBlock targetBlock = null;
        double prob;
        Set<RiscvBlock> usedLabels = new HashSet<>();
        usedLabels.add(func.blocks().get(0));

        for (RiscvBlock block : func.blocks()) {
            for (int inst : block.instructions()) {
                if (ctx.instInfo.matchBranch(inst, targetBlock, prob)) {
                    usedLabels.add(targetBlock);
                } else if (requireFlag(ctx.instInfo.getInstInfo(inst).getInstFlag(), InstFlagIndirectJump)) {
                    MIRJumpTable jumpTable = (MIRJumpTable) inst.getOperand(1).reloc();
                    for (RiscvBlock item : jumpTable.data()) {
                        usedLabels.add(item);
                    }
                }
            }
        }

        if (usedLabels.size() == func.blocks().size()) {
            return false;
        }

        RiscvBlock lastAvailable = null;

        for (RiscvBlock block : func.blocks()) {
            if (usedLabels.contains(block)) {
                lastAvailable = block;
            } else {
                for (int inst : block.instructions()) {
                    if (ctx.instInfo.matchBranch(inst, targetBlock, prob)) {
                        usedLabels.add(targetBlock);
                    }
                }
                assert lastAvailable != null;
                lastAvailable.instructions().addAll(block.instructions());
            }
        }

        func.blocks().removeIf(block -> !usedLabels.contains(block));

        return true;
    }
    public static boolean removeGotoNext(RiscvFunction func) {
        boolean modified = false;
        ListIterator<RiscvBlock> iter = func.blocks().listIterator();

        while (iter.hasNext()) {
            RiscvBlock block = iter.next();
            if (!iter.hasNext()) {
                break;
            }
            RiscvBlock nextBlock = iter.next();
            iter.previous(); // Move back the iterator to the correct position

            while (!block.instructions().isEmpty()) {
                int last = block.instructions().get(block.instructions().size() - 1);
                RiscvBlock targetBlock = null;
                if (ctx.instInfo.matchUnconditionalBranch(last, targetBlock) && targetBlock == nextBlock) {
                    block.instructions().remove(block.instructions().size() - 1);
                    modified = true;
                } else {
                    break;
                }
            }
        }
        return modified;
    }
    public static boolean removeEmptyBlocks(RiscvFunction func) {
        HashMap<RiscvBlock, RiscvBlock> redirects = new HashMap<>();
        List<RiscvBlock> currentEmptySet = new ArrayList<>();

        // Lambda function equivalent in Java
        Runnable commit = (target) -> {
            for (RiscvBlock block : currentEmptySet) {
                redirects.put(block, target);
            }
            currentEmptySet.clear();
        };

        for (RiscvBlock block : func.blocks()) {
            if (block.instructions().isEmpty()) {
                currentEmptySet.add(block);
            } else {
                commit.run(block);
            }
        }

        if (currentEmptySet.size() >= 2) {
            currentEmptySet.remove(currentEmptySet.size() - 1);
            commit.run(func.blocks().get(func.blocks().size() - 1));
        }

        for (RiscvBlock block : func.blocks()) {
            for (int inst : block.instructions()) {
                RiscvBlock targetBlock = null;
                double prob;
                if (ctx.instInfo.matchBranch(inst, targetBlock, prob)) {
                    if (redirects.containsKey(targetBlock)) {
                        ctx.instInfo.redirectBranch(inst, redirects.get(targetBlock));
                    }
                } else if (requireFlag(ctx.instInfo.getInstInfo(inst).getInstFlag(), InstFlagIndirectJump)) {
                    MIRJumpTable jumpTable = (MIRJumpTable) inst.getOperand(1).reloc();
                    for (RiscvBlock item : jumpTable.data()) {
                        if (redirects.containsKey(item)) {
                            item = redirects.get(item);
                        }
                    }
                }
            }
        }

        func.blocks().removeIf(block -> redirects.containsKey(block));

        return !redirects.isEmpty();
    }
    public static boolean conditional2Unconditional(RiscvFunction func) {
        assert ctx.flags.endsWithTerminator;
        boolean modified = false;

        ListIterator<RiscvBlock> iter = func.blocks().listIterator();

        while (iter.hasNext()) {
            RiscvBlock currentBlock = iter.next();
            if (!iter.hasNext()) {
                break;
            }
            RiscvBlock nextBlock = iter.next();
            iter.previous(); // Move back the iterator to the correct position

            List<Integer> instructions = currentBlock.instructions();
            int terminator = instructions.get(instructions.size() - 1);
            RiscvBlock targetBlock = null;
            double prob;

            if (ctx.instInfo.matchConditionalBranch(terminator, targetBlock, prob)) {
                if (targetBlock == nextBlock) {
                    instructions.set(instructions.size() - 1, ctx.instInfo.emitGoto(nextBlock));
                    modified = true;
                }
            }
        }
        return modified;
    }

    public static boolean reorderBranch(RiscvFunction func) {
        boolean modified = false;

        ListIterator<RiscvBlock> iter = func.blocks().listIterator();

        while (iter.hasNext()) {
            RiscvBlock currentBlock = iter.next();
            if (!iter.hasNext()) {
                break;
            }
            RiscvBlock nextBlock = iter.next();
            iter.previous(); // Move back the iterator to the correct position

            List<Integer> instructions = currentBlock.instructions();
            if (instructions.size() < 2) {
                continue;
            }
            int branch = instructions.get(instructions.size() - 2);
            int jump = instructions.get(instructions.size() - 1);
            RiscvBlock targetBlock = null;
            double prob;
            RiscvBlock jumpBlock = null;

            if (ctx.instInfo.matchConditionalBranch(branch, targetBlock, prob) &&
                    ctx.instInfo.matchUnconditionalBranch(jump, jumpBlock)) {
                if (targetBlock == nextBlock) {
                    ctx.instInfo.inverseBranch(branch, jumpBlock);
                    instructions.remove(instructions.size() - 1);
                    modified = true;
                }
            }
        }
        return modified;
    }
    public static boolean sfbOpt(RiscvFunction func) {
        if (ctx.flags.endsWithTerminator) {
            return false;
        }
        boolean modified = false;
        ListIterator<RiscvBlock> it = func.blocks().listIterator();

        while (it.hasNext()) {
            RiscvBlock block = it.next();
            if (!it.hasNext()) {
                continue;
            }
            RiscvBlock nextBlock = it.next();
            it.previous(); // Move back the iterator to the correct position

            List<Integer> instructions = block.instructions();
            int terminator = instructions.get(instructions.size() - 1);
            RiscvBlock targetBlock = null;
            double prob;

            if (ctx.instInfo.matchConditionalBranch(terminator, targetBlock, prob)) {
                if (targetBlock.instructions().size() != 2) {
                    continue;
                }
                int back = targetBlock.instructions().get(targetBlock.instructions().size() - 1);
                RiscvBlock next;

                if (!ctx.instInfo.matchUnconditionalBranch(back, next)) {
                    continue;
                }
                if (next != nextBlock) {
                    continue;
                }

                ctx.instInfo.inverseBranch(terminator, next);
                block.instructions().add(targetBlock.instructions().get(0));
                modified = true;
            }
        }
        return modified;
    }

    public static void simplifyCFG(RiscvFunction func) {
        while (true) {
            boolean modified = false;
            modified |= removeUnreachableCode(func, ctx);
            modified |= removeGotoNext(func, ctx);
            modified |= redirectGoto(func, ctx);
            modified |= removeEmptyBlocks(func, ctx);
            modified |= removeUnusedLabels(func, ctx);
            modified |= reorderBranch(func, ctx);
            modified |= sfbOpt(func, ctx);
            modified |= genericPeepholeOpt(func, ctx);

            if (!modified) {
                return;
            }
        }
    }

    public static void simplifyCFGWithUniqueTerminator(RiscvFunction func) {
        assert ctx.flags.endsWithTerminator;
        while (true) {
            boolean modified = false;
            modified |= conditional2Unconditional(func, ctx);
            modified |= redirectGoto(func, ctx);
            modified |= removeUnreachableCode(func, ctx);
            modified |= genericPeepholeOpt(func, ctx);

            if (!modified) {
                return;
            }
        }
    }
}
